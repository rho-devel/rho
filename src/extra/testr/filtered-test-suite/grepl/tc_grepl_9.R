expected <- eval(parse(text="c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)"));                 
test(id=0, code={                 
argv <- eval(parse(text="list(\"\\\\\\\\keyword\\\\{\\\\s*internal\\\\s*\\\\}\", c(\"\\\\inputencoding{utf8}\", \"\\\\HeaderA{condest}{Compute Approximate CONDition number and 1-Norm of (Large) Matrices}{condest}\", \"\\\\aliasA{onenormest}{condest}{onenormest}\", \"%\", \"\\\\begin{Description}\\\\relax\", \"``Estimate'', i.e. compute approximately the CONDition number of\", \"a (potentially large, often sparse) matrix \\\\code{A}.\", \"It works by apply a fast approximation of the 1-norm,\", \"\\\\code{norm(A,\\\"1\\\")}, through \\\\code{onenormest(.)}.\", \"\\\\end{Description}\", \"%\", \"\\\\begin{Usage}\", \"\\\\begin{verbatim}\", \"condest(A, t = min(n, 5), normA = norm(A, \\\"1\\\"),\", \"        silent = FALSE, quiet = TRUE)\", \"\", \"onenormest(A, t = min(n, 5), A.x, At.x, n,\", \"           silent = FALSE, quiet = silent,\", \"           iter.max = 10, eps = 4 * .Machine$double.eps)\", \"\\\\end{verbatim}\", \"\\\\end{Usage}\", \"%\", \"\\\\begin{Arguments}\", \"\\\\begin{ldescription}\", \"\\\\item[\\\\code{A}] a square matrix, optional for \\\\code{onenormest()}, where\", \"instead of \\\\code{A}, \\\\code{A.x} and \\\\code{At.x} can be specified,\", \"see there.\", \"\\\\item[\\\\code{t}] number of columns to use in the iterations.\", \"\\\\item[\\\\code{normA}] number; (an estimate of) the 1-norm of \\\\code{A}, by\", \"default \\\\code{\\\\LinkA{norm}{norm}(A, \\\"1\\\")}; may be replaced by an estimate.\", \"\\\\item[\\\\code{silent}] logical indicating if warning and (by default)\", \"convergence messages should be displayed.\", \"\\\\item[\\\\code{quiet}] logical indicating if convergence messages should be\", \"displayed.\", \"\\\\item[\\\\code{A.x, At.x}] when \\\\code{A} is missing, these two must be given as\", \"functions which compute \\\\code{A \\\\%\\\\% x}, or \\\\code{t(A) \\\\%\\\\% x},\", \"respectively.\", \"\\\\item[\\\\code{n}] \\\\code{ == nrow(A)}, only needed when \\\\code{A} is not specified.\", \"\\\\item[\\\\code{iter.max}] maximal number of iterations for the 1-norm estimator.\", \"\\\\item[\\\\code{eps}] the relaive change that is deemed irrelevant.\", \"\\\\end{ldescription}\", \"\\\\end{Arguments}\", \"%\", \"\\\\begin{Value}\", \"Both functions return a \\\\code{\\\\LinkA{list}{list}};\", \"\\\\code{onenormest()} with components,\", \"\\\\begin{ldescription}\", \"\\\\item[\\\\code{est}] a number \\\\eqn{> 0}{}, the estimated \\\\code{norm(A, \\\"1\\\")}.\", \"\\\\item[\\\\code{v}] the maximal \\\\eqn{A X}{} column.\", \"\", \"\\\\end{ldescription}\", \"The function \\\\code{condest()} returns a list with components,\", \"\\\\begin{ldescription}\", \"\\\\item[\\\\code{est}] a number \\\\eqn{> 0}{}, the estimated condition number\", \"\\\\eqn{\\\\hat\\\\kappa}{}; when \\\\eqn{r :=}{}\\\\code{rcond(A)},\", \"\\\\eqn{1/\\\\hat\\\\kappa \\\\approx r}{}.\", \"\\\\item[\\\\code{v}] integer vector length \\\\code{n}, with an \\\\code{1} at the index\", \"\\\\code{j} with maximal column \\\\code{A[,j]} in \\\\eqn{A}{}.\", \"\\\\item[\\\\code{w}] numeric vector, the largest \\\\eqn{A x}{} found.\", \"\\\\item[\\\\code{iter}] the number of iterations used.\", \"\\\\end{ldescription}\", \"\\\\end{Value}\", \"%\", \"\\\\begin{Author}\\\\relax\", \"This is based on octave's \\\\code{condest()} and\", \"\\\\code{onenormest()} implementations with original author\", \"Jason Riedy, U Berkeley; translation to \\\\R{} and\", \"adaption by Martin Maechler.\", \"\\\\end{Author}\", \"%\", \"\\\\begin{References}\\\\relax\", \"\", \"Nicholas J. Higham and Fran\\303\\247oise Tisseur (2000).\", \"A Block Algorithm for Matrix 1-Norm Estimation, with an Application to 1-Norm\", \"Pseudospectra.\", \"\\\\emph{SIAM J. Matrix Anal. Appl.} \\\\bold{21}, 4, 1185--1201.\", \"\\\\url{http://dx.doi.org/10.1137/S0895479899356080}\", \"\", \"\", \"William W. Hager (1984).\", \"Condition Estimates.\", \"\\\\emph{SIAM J. Sci. Stat. Comput.} \\\\bold{5}, 311--316.\", \"\\\\end{References}\", \"%\", \"\\\\begin{SeeAlso}\\\\relax\", \"\\\\code{\\\\LinkA{norm}{norm}}, \\\\code{\\\\LinkA{rcond}{rcond}}.\", \"\\\\end{SeeAlso}\", \"%\", \"\\\\begin{Examples}\", \"\\\\begin{ExampleCode}\", \"data(KNex)\", \"mtm <- with(KNex, crossprod(mm))\", \"system.time(ce <- condest(mtm))\", \"## reciprocal\", \"1 / ce$est\", \"system.time(rc <- rcond(mtm)) # takes ca  3 x  longer\", \"rc\", \"all.equal(rc, 1/ce$est) # TRUE -- the approxmation was good\", \"\\\\end{ExampleCode}\", \"\\\\end{Examples}\"), FALSE, FALSE, TRUE, FALSE, FALSE, FALSE)"));                 
.Internal(grepl(argv[[1]], argv[[2]], argv[[3]], argv[[4]], argv[[5]], argv[[6]], argv[[7]], argv[[8]]));                 
}, o=expected);                 

