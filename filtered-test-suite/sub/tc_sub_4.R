expected <- eval(parse(text="c(\"\", \"\\036Merged in a set of Splus code changes that had accumulated at Mayo\", \"    over the course of a decade. The primary one is a change in how\", \"    indexing is done in the underlying C code, which leads to a major\", \"    speed increase for large data sets.  Essentially, for the lower\", \"    leaves all our time used to be eaten up by bookkeeping, and this\", \"    was replaced by a different approach.  The primary routine also\", \"    uses .Call{} so as to be more memory efficient.\", \"\", \"\\036The other major change was an error for asymmetric loss matrices,\", \"    prompted by a user query.  With L=loss asymmetric, the altered\", \"    priors were computed incorrectly - they were using L' instead of L.\", \"    Upshot - the tree would not not necessarily choose optimal splits\", \"    for the given loss matrix.  Once chosen, splits were evaluated\", \"    correctly.  The printed “improvement” values are of course the\", \"    wrong ones as well.  It is interesting that for my little test\", \"    case, with L quite asymmetric, the early splits in the tree are\", \"    unchanged - a good split still looks good.\", \"\", \"\\036Add the return.all argument to xpred.rpart().\", \"\", \"\\036Added a set of formal tests, i.e., cases with known answers to\", \"    which we can compare.\", \"\", \"\\036Add a usercode vignette, explaining how to add user defined\", \"    splitting functions.\", \"\", \"\\036The class method now also returns the node probability.\", \"\", \"\\036Add the stagec data set, used in some tests.\", \"\", \"\\036The plot.rpart routine needs to store a value that will be visible\", \"    to the rpartco routine at a later time.  This is now done in an\", \"    environment in the namespace.\", \"\")"));               
test(id=0, code={               
argv <- eval(parse(text="list(\"^  \\036 \", \"\\036\", c(\"\", \"  \\036 Merged in a set of Splus code changes that had accumulated at Mayo\", \"    over the course of a decade. The primary one is a change in how\", \"    indexing is done in the underlying C code, which leads to a major\", \"    speed increase for large data sets.  Essentially, for the lower\", \"    leaves all our time used to be eaten up by bookkeeping, and this\", \"    was replaced by a different approach.  The primary routine also\", \"    uses .Call{} so as to be more memory efficient.\", \"\", \"  \\036 The other major change was an error for asymmetric loss matrices,\", \"    prompted by a user query.  With L=loss asymmetric, the altered\", \"    priors were computed incorrectly - they were using L' instead of L.\", \"    Upshot - the tree would not not necessarily choose optimal splits\", \"    for the given loss matrix.  Once chosen, splits were evaluated\", \"    correctly.  The printed “improvement” values are of course the\", \"    wrong ones as well.  It is interesting that for my little test\", \"    case, with L quite asymmetric, the early splits in the tree are\", \"    unchanged - a good split still looks good.\", \"\", \"  \\036 Add the return.all argument to xpred.rpart().\", \"\", \"  \\036 Added a set of formal tests, i.e., cases with known answers to\", \"    which we can compare.\", \"\", \"  \\036 Add a usercode vignette, explaining how to add user defined\", \"    splitting functions.\", \"\", \"  \\036 The class method now also returns the node probability.\", \"\", \"  \\036 Add the stagec data set, used in some tests.\", \"\", \"  \\036 The plot.rpart routine needs to store a value that will be visible\", \"    to the rpartco routine at a later time.  This is now done in an\", \"    environment in the namespace.\", \"\"), FALSE, FALSE, FALSE, FALSE)"));               
.Internal(sub(argv[[1]], argv[[2]], argv[[3]], argv[[4]], argv[[5]], argv[[6]], argv[[7]]));               
}, o=expected);               

